\documentclass[10pt,a4paper]{article}

%_______Llamo paquetes_____________________
\usepackage[margin=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}			%Descripciones
\usepackage{multicol}			%Columnas
\usepackage{setspace}
\usepackage{listings}			%Formato código
\usepackage{xcolor}
\usepackage[spanish,mexico]{babel}
\usepackage{hyperref}           %Vínculos clickeables
%_______Configuro el paquete de listing____
\lstset{language=Python}
\lstset{frame=lines}
\lstset{label={lst:code_direct}}
\lstset{basicstyle=\footnotesize}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
backgroundcolor=\color{backcolour},   
commentstyle=\color{codegreen},
keywordstyle=\color{magenta},
numberstyle=\tiny\color{codegray},
stringstyle=\color{codepurple},
basicstyle=\ttfamily\footnotesize,
breakatwhitespace=false,         
breaklines=true,                 
captionpos=b,                    
keepspaces=true,                 
numbers=left,                    
numbersep=5pt,                  
showspaces=false,                
showstringspaces=false,
showtabs=false,                  
tabsize=2
}

\lstset{style=mystyle}


%_______Formato y títulos__________________


\author{Federico E. Benelli}
\title{" Python Basics for Data Science" - Resumen escrito en \LaTeX{}}

\renewcommand*\contentsname{Tabla de contenidos}
\onehalfspacing
\setlength{\columnseprule}{0.75pt}
\setlength{\columnsep}{3em}

%_______Comienzo el documento______________


\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introducción}
Python es un lenguaje de programación

\section{Basics}

\subsection{Tipos básicos de datos}

\begin{description}[
align=right,
labelindent = 1cm,
labelsep=0.5cm,
itemindent=0cm]

\item [Integer]Números enteros
\item [Float]Números flotantes. Es como se denomina a los números decimales en programación, esta denominación viene dada porque por defecto las computadoras no realizan con total precisión cálculos de fracciones. Por ejemplo, si en la consola de Python se escribe "0.1 + 0.2" esta devolverá "0.30000000000000004" en lugar del esperado "0.3" (explicación más detallada en https://www.youtube.com/watch?v=PZRI1IfStY0)
\item [String]Strings son secuencias de caracteres (usualmente texto), se escriben entre " " o ' ', también se pueden hacer bloques de texto entre """ """
\item [Boolean] Son los booleanos "True" y "False"
\end{description}

\subsection{Funciones básicas de Python}
Se describen las funciones básicas presentes en Python 3.7. 

\begin{description}[align=right,labelwidth=1cm,labelsep=0.5cm, itemindent=0cm]


\item [type(x)] Retorna el tipo de variable que es x, por ejemplo si realizo:
\begin{lstlisting}
>> type('texto de ejemplo')
>> <class 'str'>\end{lstlisting}
\item [print(x)] Muestra en la consola la variable x, soporta muchos tipos de variables, no solo string
\begin{lstlisting}
>> print('texto de ejemplo')
>> texto de ejemplo\end{lstlisting}
\item [round(x)] Redondea el valor de un número flotante x, por defecto redondea totalmente
\begin{lstlisting}
>> round(2.53)
>> 3
>> round(2.53,1)
>> 2.5\end{lstlisting}
\item [float(x)] Retorna el valor de x convertido en tipo número flotante, puede recibir íntegros o strings, siempre y cuando la string sea solo un número.
\begin{lstlisting}
>> float("2")
>> 2.0\end{lstlisting}

\item [int(x)] Retorna el valor íntegro de x, solo puede recibir variables del tipo float o string si es que esta es solo un int. Si utilizo la función int en el booleano "True" obtengo un 1, y si lo realizo en el booleano "False" obtengo un 0
\begin{lstlisting}
>> int(2.731)
>> 2\end{lstlisting}


\end{description}

\subsection{Expresiones en Python}
En Python pueden realizarse las operaciones básicas de matemáticas, utilizando '*' y '**' para la multiplicación y potenciam, respectivamente. Además se pueden utilizar el símbolo '\%' para obtener el resto de una división y '//' para obtener el cociente entero. En el caso de strings, estas también pueden ser sumadas y multiplicadas por un íntegro.

\begin{multicols}{4}[Ejemplos]
\noindent
\begin{lstlisting}
>> 5+5
>> 10
>> "abc"+"def"
>> "abcdef"\end{lstlisting}
\vfill\null \columnbreak
\noindent
\begin{lstlisting}
>> 5-5
>> 0
>> 5*5
>> 10
\end{lstlisting}
\vfill\null \columnbreak
\noindent

\begin{lstlisting}	
>> 5/5
>> 1
>> 5**5
>> 125\end{lstlisting}
\vfill\null \columnbreak

\begin{lstlisting}
>> 25%4
>> 1
>> 25//4
>> 6\end{lstlisting}
\end{multicols}


\subsection{Variables en Python}
Las variables se utilizan para almacenar valores, los cuales pueden ser reutilizados luego, las variables también pueden almacenar el resultado de expresiones.
\begin{lstlisting}
>> variables = 25 + 25
>> variable
>> 50\end{lstlisting}

Si cambio el valor de una variable, esto afectara el valor de otras variables que la incluyan
\begin{lstlisting}
>> variable1 = 25
>> variable2 = variable1+25
>> variable2
>> 50
\end{lstlisting}
Al reasignar variable1 y volver a llamar a variable2
\begin{lstlisting}
>> variable1 = 50
>> variable2
>> 75\end{lstlisting}

\section{Data Structure}

\subsection{Tipos de estructuras de datos}

\begin{description}[
align=right,
labelindent = 1cm,
labelsep=0.5cm,
itemindent=0cm]

\item [list] 
Las listas son conjuntos ordenados de valores de cualquier tipo de dato, se expresan como [dato1, dato2, dato3, etc].\\
Se almacenan como variables y pueden contener variables dentro de ellas.

\begin{lstlisting}
>> variable1 = 25
>> variable2 = variable1+25
>> lista = [variable1, variable2, 'tercer elemento', 4.23]\end{lstlisting} 
Los elementos de las listas se llaman de la siguiente manera:

\begin{description}[leftmargin=!,labelwidth=2.5cm,itemindent=0cm]
\item [{$>>$ lista[0]}] \textit{Llamado al primer elemento de la lista, en Python todos los contadores comienzan en cero, devuelve 25}
\item [{$>>$ lista[-1]}] \textit{Llamado al último elemento de la lista, devuelve 4.23}
\item [{$>>$ lista[1:3]}] \textit{Llama a los elementos del 1 al 3 de la lista, en este caso devuelve \emph{[50, 'tercer elemento', 4.23]}}
\item [{$>>$ lista[a:b:c]}] \textit{Llama a los elementos de 'a' a 'b', yendo de c en c, si no se dan valores de a y/o b se considera la lista completa, \emph{lista[::2]} devuelve \emph{[25,'tercer elemento']}, si el valor de c es negativo el conteo será de fin a principio}
\end{description}

Las listas son mutables, eso quiere decir que sus elementos pueden ser modificados.\\
\begin{lstlisting}
>> lista = [1, 2, 3]
>> lista[1] = 25
>> lista
>> [25, 2, 3]\end{lstlisting}

Si defino una variable a una lista y luego otra variable a esa variable, cualquier cambio que le realice a la lista de la primer variable también será realizado en la segunda variable, esto ocurre debido a que ambas variables apuntan a la misma lista ubicada en la memoria.\\
\begin{lstlisting}
>> lista1 = [1, 2, 3]
>> lista2 = lista1
>> lista1[1] = 23
>> lista2
>> [1, 23, 3]\end{lstlisting}
Esto puede ser evitado 'clonando' a la primer variable, esto se realiza llamando a todos los elementos de la primer variable al momento de definir la segunda\\
\begin{lstlisting}
>> lista1 = [1, 2, 3]
>> lista2 = lista1[:]\end{lstlisting}
\textbf{Métodos aplicables en listas}
\begin{description}
\item [lista.extend(iterable)] Añade los elementos de un iterable a una lista.
\item [lista.append(object)] Añade el objeto al final de la lista.
\end{description}
\textit{Más métodos y funciones pueden consultarse con \emph{help(list())}}

\item [tuple]
Las tuplas son similares a las listas, solo que se definen entre paréntesis (elemento1, elemento2, elemento3, etc) y son inmutables, por lo que una vez que son definidas no pueden ser modificadas.\\ Los elementos de las tuplas se llaman de igual manera que en las listas.

\item [set]
Son conjuntos de elementos que no poseen un orden en particular, se definen como {elemento1, elemento2, etc}, pueden ser vistas como conjuntos de \emph{Venn}. Los elementos repetidos se eliminan automáticamente\\

\textbf{Métodos}
\begin{description}
\item [set.add(element)] Añade el elemento al set.
\item [set.remove(element)] Remueve el elemento del set.
\item [set1.intersection(set2)] Devuelve un set con la intersección de ambos sets.
\item [set1.union(set2)] Devuelve un set con la unión de ambos sets.
\item [set1.difference(set2)] Devuelve un set con los elementos fuera de la intersección de ambos sets.
\item [set1.issubset(set2)] Devuelve True o False dependiendo si es subset o no.
\item [set1.issuperset(set2)] Equivalente al anterior
\end{description}
\textit{Más métodos pueden hallarse con \emph{help(set())}}

\item [dictionary]
Los diccionarios son conjuntos de elementos con índices para facilitar el acceso a los elementos. Se definen como \{"índice1":\{elemento1,elemento2\},"índice2":\{elemento3, elemento4\}\}
Los elementos de los diccionarios se definen y llaman de la siguiente manera:

\begin{description}[leftmargin=!,labelwidth=2.5cm,itemindent=0cm]
\item [{$>>$ dic['índice1'] = \{elemento1,elemento2\}}] Asigna el conjunto de elementos al índice 1, si el índice 1 no existía aún lo crea automáticamente.
\item [{$>>$ dic['índice1']}]   Devuelve los elementos correspondientes al índice 1, {elemento1, elemento2} 
\end{description}
\end{description}
\section{Programming Fundamentals}
\subsection{Condiciones}
En Python pueden realizarse distintos tipos de comparaciones entre objetos/expresiones, las cuales devuelven un valor booleano del tipo \emph{True} o \emph{False} dependiendo de la comparación.\\
Los distintos tipos de comparaciones que se pueden realizar en Python son:\\
\begin{description}[leftmargin=!, labelwidth=2.5cm,itemindent=0cm]
\item [A $>$ B] Devuelve \emph{True} si A es mayor que B
\item [A $<$ B] Devuelve \emph{True} si A es menor que B
\item [A == B] Devuleve \emph{True} si A es igual a B (funciona con cualquier tipo de objeto, no solo números)
\item [A != B] Devuelve \emph{True} si A es distinto a B (con cualquier tipo de objeto) 
\item [A $>=$ B] Devuelve \emph{True} si A es mayor o igual a B
\item [A $<=$ B] Devuelve \emph{True} si A es menor o igual a B
\end{description}
\noindent Estas comparaciones son útiles a la hora de condicionar la ejecución de parte del código, así esta parte solo es ejecutada si y solo si cumple con cierta condición. para esto se utiliza la declaración \emph{if} de la siguiente manera:.
\begin{lstlisting}
if condicion:
    codigo a utilizar si se cumple la condicion
else:
    codigo a utilizar si la condicion no se cumple #opcional\end{lstlisting}
\subsection{Loops}
Los loops son formas de simplificar código que va a repetirse reiteradas veces o de manera iterativa, también facilitando su modificación en el caso de que sea necesario, por ejemplo, existen dos maneras de hacer que un código repita 5 veces el comando \emph{print("Hello, world!")}:
\begin{multicols}{2}
\begin{lstlisting}
print("Hello, world")
print("Hello, world")
print("Hello, world")
print("Hello, world")
print("Hello, world")\end{lstlisting}
\vfill\null \columnbreak
\noindent
\begin{lstlisting}
for i in range(0,5):
    print("Hello, world!")\end{lstlisting}
\end{multicols}
\noindent Siguiendo con el ejemplo, si se quisiera cambiar el código por uno el cual la línea se escriba 20 veces en el primer caso sería necesario reescribir esa misma linea 15 veces más cuando en el segundo caso con simplemente cambiar el número "5" por un "20". Queda claro que la segunda opción es mucho más simple, y al mismo tiempo estas complejidades incrementan exponencialmente si el código se vuelve más complejo.
\begin{description}[
align=right,
labelindent=1cm,
labelsep=0.5cm,
itemindent=0cm]
\item [while] La declaración \emph{while} se utiliza de manera similar a la declaración \emph{if}, funciona con una condición y, a diferencia de la declaración \emph{if} que reproduce el código una sola vez, esta repite el bloque de código hasta que la condición sea \emph{True}
\item [for] La declaración \emph{for} funciona designando valores a una nueva variable dentro de esta, reasignándole valores en función de un objeto iterable.
\end{description}

\noindent Como se dijo previamente, la declaración \emph{for} designa un iterable, usualmente los iterables que se utilizan son:

\begin{description}[labelsep=0.5cm, itemindent=0cm]

\item [list]
En el caso de declarar \emph{for element in list:}, la varibale \emph{element} tomará los valores de los elementos de la lista en la iteración. También puede utilizarse la función \emph{enumerate}, con la cual además de iterar sobre los valores de la lista se obtiene el índice de cada elemento, la declaración se realiza de la forma \emph{for i,element in enumerate(list):}  
\item [range(in,fin,step)]
La función \emph{range(in,fin,step)} devuelve un objeto iterable el cual consiste en un rango de números, donde \emph{in} es el número inicial, \emph{fin} el número final y \emph{step} el paso en el cual se realiza el conteo. La declaración será, por ejemplo la declaración \emph{for i in range(0,15,2):} asignará a \emph{i} los valores entre 0 y 15, de dos en dos. Nótese que el valor final jamás es alcanzado, por lo que si utilizo \emph{range(0,10)} se obtendrán los valores 0,1..9.
\item [dictionary]
Si se itera en un diccionario mediante la declaración \emph{for} la variable asignada obtendrá los valores de las \emph{"key"} del mismo, en formato \emph{string}
\end{description}
\noindent Nótese que si bien existen convenciones de utilizar el nombre de variable \emph{`i'} en una declaración, no es una condición necesaria para que el código funcione, esta puede tomar cualquier nombre designado por el autor.
\subsection{Funciones}
En Python pueden utilizarse funciones para simplificar código que se repite en múltiples etapas. las funciones se declaran y llaman de la siguiente manera:
\begin{lstlisting}
def function(input1,inputb,...):
    metodo a implementar
    return result

a = 2
b = 3
function(a,b)
\end{lstlisting} 
\noindent Una función aplica métodos al momento de ser llamada, las variables utilizadas dentro de ellas no afectan a las variables globales del código aunque pueden leerlas, pueden recibir elementos sobre los cual trabajar y devuelve un resultado (también puede aplicar un método que no devuelve resultado). Se pueden generar variables globales dentro de una función antecediendo a la misma con \emph{"global"}
\begin{lstlisting}
def function(input1,input2,...):
    result = input1 + input2
    global variable_nueva
    variable_nueva = result + 10    
    return result

a = 2
b = 3

suma = function(a,b)

print(suma)
>> 5
print(variable_nueva)
>> 15
\end{lstlisting} 

\subsection{Objetos y clases}
Una clase es una definición general de un elemento el cual posee ciertos atributos y al cual se le pueden ser aplicados ciertos métodos, por ejemplo, una lista es un objeto al cual pueden aplicársele métodos como \emph{*.append(elemento)}
Los pasos de utilización de una clase se van a realizar mediante el siguiente ejemplo
\subsubsection{Definición de una clase}
Se va a definir una clase llamada \emph{Persona}, la cual posee características básicas de una persona y se va a tener un método mediante el cual puede modificarse su domicilio.
\begin{lstlisting}[caption={Definición de una clase}]
"""
En primer medida se define el nombre de la clase y puede utilizarse una clase "madre" de la cual se heredan todos los metodos y atributos de ese tipo de clase ademas de los que se agregan en la defiinicion, por el momento solo se utilizara "object"
"""
class Persona(object):
    
    def __init__(self, nombre, apellido, domicilio, edad):  
        """
        Los atributos del nuevo objeto son definidos por la funcion "__init__", la cual siempre comienza con el parametro "self", el cual hace referencia al objeto y luego es seguida por los atributos.
        Dentro de la funcion los atributos son definidos como self.atributo = atributo
        """
        self.nombre = nombre                               
        self.apellido = apellido
        self.domicilio = domicilio
        self.edad = edad
        
    def info():
        """
        Metodo que devuelve los datos del objeto al ser utilizado
        """
        print(self.nombre)
        print(self.apellido)
        print(self.domicilio)
        print(self.edad)
    
    def mudar(nueva_direccion):
        """
        Metodo que reasigna un nuevo domicilio al objeto
        """
        self.domicilio = nueva_direccion
\end{lstlisting}
\newpage
\subsubsection{Utilización de clases}
\begin{lstlisting}[caption={Utilización de objetos de una clase, output de consola presentado como $``>>"$}]

# Comienzo definiendo variables a un objetos Persona
alumno_1 = Persona("Jose", "Perez", "Independencia 1153, Cordoba", "28")

# Si no se aclara el atributo el programa asume que es el de la misma posicion que en la definicion de la Clase (obviando el "self"), la siguiente definicion (si bien caotica) es valida
alumno_2 = Persona(direccion="Santa Fe 24, Cordoba", "Gonzalez", nombre="Marcos" ,"52")

# Ahora pueden aplicarse los metodos o llamarse a los atributos individuales

print(alumno_1.edad)
>> 28

alumno_2.info()
>> Marcos
>> Gonzalez
>> Santa Fe 24, Cordoba
>> 52

alumno_1.mudar("Bv. Chacabuco 729, Cordoba")
alumno_1.info()
>> Jose
>> Perez
>> Bv. Chacabuco 729, Cordoba
>> 52
\end{lstlisting}
\section{Working with Data}
\subsection{Leyendo y escribiendo archivos}
Los archivos pueden ser abiertos y modificados en Python utilizando la funcione \emph{open(a, b)}, donde \emph{a} es el nombre del archivo y b el modo en el cual se abre el archivo (\emph{r} para leer y \emph{w} para escribir), en ambos casos la funcion \emph{open()} genera un objeto al cual es necesario aplicarle métodos para poder utilizarlo.
A la hora de leer archivos los dos métodos principales a utilizar son \emph{*.read()}, \emph{*.readline() y \emph{*.readlines()}}. Los archivos abiertos con la función \emph{open()} se leen caracter por caracter cada vez que se aplica un método y la posición del cursor queda registrada por lo que no se puede volver a leer caracteres ya leidos.

\begin{lstlisting}[caption={Leer y escribir datos de un archivo}]
# Defino una variable al archivo, en modo de lectura
feed = open("archivo.txt", "r")

# El metodo "read()" lee todos los datos del archivo y los devuelve como string
datos = feed.read()

# El metodo "readline()" lee linea por linea cada vez que es llamado y devuleve una string.
# En este caso, ambas variables tendran el valor de una string nula debido a que todo el archivo fue leido previamente al utilizar feed.read()

primer_linea = f.readline()
segunda_linea = f.readline()

# El metodo "readlines()" lee todas las lineas y las devuelve como una lista, donde cada elemento es una linea
lineas = f.readlines()

# Al terminar de leer el archivo este debe cerrarse, lo recomendable es cerrarlo lo antes posible para evitar perdida de datos en caso de haber un error en el programa
f.close()

# Una forma mas facil de trabajar es la siguiente, se utiliza el modo de escritura en el ejemplo pero puede usarse en lectura tambien. mediante la declaracion "with" el archivo se abre y es definido con la variable declarada luego de "as", el archivo se cierra automaticamente tras correr el codigo del bloque indentado
with open(file, "w") as w:
    nuevos_datos = "Estoy sobreescribiendo datos en el archivo!"
    w.write(nuevos_datos)

# Si quisiera agregar datos al archivo debo primero leerlo
with open(file, "r") as f:
    feed = f.read()

with open(file, "w") as w:
    nuevos_datos = "esta vez voy a agregar datos a los existentes"
    feed += nuevos_datos
    w.write(feed) 
\end{lstlisting}
\subsection{Cargar data con Pandas}
Pandas es una librería de Python con foco en estructuras de datos y herramientas de análisis de datos fáciles de utilizar y de alta performance.\cite{pandas}

En Pandas se trabajo con objetos llamados \emph{DataFrames}, los cuales son equivalentes a las listas en Python, y usualmente se trata de tablas de dos dimensiones (similar a una tabla Excel)
\subsubsection{}
\subsubsection{Métodos de Pandas}
\begin{description}
\item [df.head()] Devuelve las primeras 5 filas del DataFrame
\item [{df[['columna']]}]  Devuelve la columna de título 'columna', también puede utilizarse el número de columna
\item [df.loc['Fila1':'Fila2', 'Columna2':'Columna5']] Devuelve los valores entre las filas y columnas designadas en función de sus títulos
\item [{df.iloc[a:b, c:d]}] Devuelve los valores entre entre las filas a y b, y las columnas c y d; donde a, b, c y d son los valores de índice numéricos.
\end{description}
Más información puede consultarse en la documentación de Pandas \cite{pandasDoc}
\section{Working with NumPy arrays}

\begin{thebibliography}{9}

\bibitem{edXcourse1}
IBM,
\textit{ IBM: PY0101EN Python Basics for Data Science},
edX.org,
2017.

\bibitem{pandas}
Pandas,
PyData.org,
url=https://pandas.pydata.org/

\bibitem{pandasDoc}
Pandas Documentation,
PyData.org,
url=\url{https://pandas.pydata.org/pandas-docs/stable/}

\end{thebibliography}
\end{document}
